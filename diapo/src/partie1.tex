\section{Analyse préliminaire du programme}

\subsection{Test de détection de la vulnérabilité}

Pour identifier la faille, nous avons exécuté le programme en fournissant une chaîne de caractères contenant des spécificateurs de format. Si le programme est vulnérable, il interprétera ces spécificateurs au lieu de les afficher littéralement.

Nous avons utilisé le payload suivant : \code{AAAA \%p \%p \%p \%p \%p}.
\begin{itemize}
    \item \code{AAAA} : Sert de motif reconnaissable (0x41414141) pour repérer notre buffer sur la pile.
    \item \code{\%p} : Spécificateur de format demandant l'affichage d'un pointeur (adresse mémoire) situé sur la pile.
\end{itemize}

Voici le résultat de l'exécution dans notre environnement de test :

\begin{lstlisting}[caption={Test d'injection de chaînes de format}, language=bash]
thomas@zephyrus:~/work/devoir2026$ ./vuln 
Checking ping is on the system...
/usr/bin/ping
Please Insert an IP address to ping: 
AAAA %p %p %p %p %p
AAAA 0x5acad81676b1 0xfbad2288 0x7e170491ba91 0x5acad81676c4 0x410
ping: %p: Name or service not known
\end{lstlisting}

\subsection{Interprétation des résultats}

L'analyse de la sortie confirme la présence de la vulnérabilité :

\begin{enumerate}
    \item \textbf{Interprétation des formats :} Le programme n'a pas affiché la chaîne littérale \texttt{"\%p \%p..."}. À la place, il a affiché des valeurs hexadécimales (\texttt{0x5acad81676b1}, \texttt{0xfbad2288}, etc.).
    \item \textbf{Fuite de mémoire (Exfiltration) :} Ces valeurs hexadécimales correspondent au contenu de la pile (Stack) au moment de l'appel à la fonction d'affichage. Comme expliqué dans le cours, la fonction \texttt{printf} (ou famille) dépile les arguments correspondants aux spécificateurs \texttt{\%p} même s'ils n'ont pas été fournis par le programmeur.
\end{enumerate}

\subsection{Nature exacte de la vulnérabilité}

La vulnérabilité détectée est une \textbf{Format String Vulnerability} (CWE-134).

\paragraph{Justification théorique :}
En langage C, les fonctions d'affichage formaté comme \texttt{printf} attendent une chaîne de format suivie d'arguments optionnels. Une implémentation sécurisée devrait être :
\begin{lstlisting}[language=C]
printf("%s", user_input);
\end{lstlisting}
Ici, le comportement observé indique que l'entrée utilisateur est passée directement comme premier argument (chaîne de format) :
\begin{lstlisting}[language=C]
printf(user_input);
\end{lstlisting}

\subsection{Capacités offertes par la vulnérabilité}

Cette vulnérabilité offre deux vecteurs d'attaque principaux nécessaires pour la suite de l'exploitation :

\begin{itemize}
    \item \textbf{Exfiltration de données (Lecture) :} Comme démontré par notre test, l'utilisation de \texttt{\%p} (ou \texttt{\%x}, \texttt{\%s}) permet de lire le contenu de la pile. Cela nous permettra de contourner les protections comme l'ASLR/PIE en récupérant des adresses mémoires valides (adresses de retour, pointeurs de pile, adresse de base de la libc).
    
    \item \textbf{Modification de la mémoire (Écriture) :} Bien que non visible dans la sortie standard, la nature de la faille \textit{Format String} permet l'utilisation du spécificateur \texttt{\%n} (et ses variantes \texttt{\%hn}, \texttt{\%hhn}). Ce spécificateur est particulier car il n'affiche rien mais \textbf{écrit} le nombre de caractères affichés jusqu'à présent dans l'adresse pointée par l'argument correspondant sur la pile. C'est ce mécanisme qui permettra d'écraser l'adresse de retour (Saved RIP) pour rediriger le flux d'exécution vers notre chaîne ROP.
\end{itemize}

\vspace{0.5cm}
\textbf{Conclusion :} Le programme est vulnérable. Nous pouvons lire la pile pour calculer les offsets nécessaires et nous pouvons écrire en mémoire pour détourner le flux d'exécution.