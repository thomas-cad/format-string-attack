\section{Préparation de la charge utile}

% --- Slide 1 : Placement de /bin/sh ---
\begin{frame}{Placement de la chaîne \texttt{"/bin/sh"}}
    \textbf{Objectif :} appeler \texttt{system("/bin/sh")} $\rightarrow$ RDI doit pointer vers \texttt{"/bin/sh"}

    \vspace{0.3cm}
    \textbf{Emplacement choisi : Mot n\textsuperscript{o}28} (juste après le Saved RIP)
    \begin{itemize}
        \item Dans la stack frame de \texttt{main} $\rightarrow$ zone \textbf{stable} entre les itérations
        \item Contrairement aux variables locales de \texttt{makePing} (réinitialisées à chaque appel)
    \end{itemize}

    \vspace{0.3cm}
    \textbf{Encodage Little Endian :}
    \begin{itemize}
        \item \texttt{/bin/sh\textbackslash 0} $\rightarrow$ \texttt{2f 62 69 6e 2f 73 68 00}
        \item Entier 64 bits : \textbf{\texttt{0x0068732f6e69622f}}
    \end{itemize}
\end{frame}

% --- Slide 2 : ROP Chain ---
\begin{frame}{Organisation de la ROP Chain}
    \begin{table}
        \centering
        \begin{tabular}{|c|c|l|}
            \hline
            \textbf{Ordre exec.} & \textbf{Position} & \textbf{Contenu} \\
            \hline
            1 & Saved RIP & Adresse Gadget (\texttt{pop rdi ; ret}) \\
            \hline
            2 & RIP + 8 & Adresse de \texttt{"/bin/sh"} \\
            \hline
            3 & RIP + 16 & Adresse de \texttt{system} \\
            \hline
        \end{tabular}
    \end{table}

    \vspace{0.3cm}
    \textbf{Écriture en ordre inverse} (du haut vers le bas) :
    \begin{enumerate}
        \item Écrire \texttt{system} en RIP+16 $\rightarrow$ la boucle continue
        \item Écrire adresse de \texttt{"/bin/sh"} en RIP+8 $\rightarrow$ la boucle continue
        \item Écraser Saved RIP avec le Gadget $\rightarrow$ \textbf{la ROP chain se déclenche}
    \end{enumerate}

    \vspace{0.2cm}
    \small{Si on écrasait le Saved RIP en premier, la boucle se briserait avant que les arguments soient en place $\rightarrow$ crash.}
\end{frame}
