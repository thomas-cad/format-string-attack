\section{Préparation de la charge utile (Payload)}

L'exploitation repose sur la construction d'une chaîne ROP (Return-Oriented Programming) directement sur la pile. Puisque nous exploitons une vulnérabilité de format string avec une taille de buffer limitée, nous ne pouvons pas écrire toute la chaîne en une seule fois.

Nous utilisons la boucle d'exploitation (créée en modifiant le LSB du Saved RIP à l'adresse \texttt{RBP+8}) pour écrire la chaîne ROP élément par élément dans les adresses supérieures.

\subsection{Placement des données}

Pour obtenir un shell, nous devons appeler la fonction \texttt{system("/bin/sh")}.
Selon la convention d'appel x86\_64, le premier argument doit être placé dans le registre \texttt{RDI}. Le registre \texttt{RDI} devra donc contenir \textbf{l'adresse mémoire} (pointeur) vers la chaîne \texttt{"/bin/sh"}.

\textbf{Zone de stockage de la chaîne :}
Nous choisissons de stocker la chaîne \texttt{"/bin/sh"} à l'adresse \texttt{RBP + 40}.
Cet emplacement est suffisamment éloigné pour ne pas interférer avec l'exécution du Gadget et de System.

\textbf{Encodage Little Endian :}
La chaîne \texttt{/bin/sh\textbackslash0} est convertie en entier 64 bits inversé : \textbf{\texttt{0x0068732f6e69622f}}.

\subsection{Stratégie d'insertion et Structure ROP}

La chaîne ROP finale est construite à partir de l'offset \texttt{RBP + 16}, juste après l'adresse de retour utilisée pour la boucle.

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|l|l|}
        \hline
        \textbf{Offset Pile} & \textbf{Adresse Python} & \textbf{Contenu} & \textbf{Rôle} \\
        \hline
        \texttt{RBP + 8} & \texttt{addr\_rip} & \texttt{...EE} & Maintien de la boucle \\
        \hline
        \texttt{RBP + 16} & \texttt{addr\_rbp + 16} & \texttt{Gadget POP RDI} & Charge RDI avec la valeur suivante \\
        \hline
        \texttt{RBP + 24} & \texttt{addr\_rbp + 24} & \texttt{Adresse Chaîne} & Argument (Pointeur vers RBP+40) \\
        \hline
        \texttt{RBP + 32} & \texttt{addr\_rbp + 32} & \texttt{Adresse System} & Appel de \texttt{system()} \\
        \hline
        \texttt{RBP + 40} & \texttt{addr\_rbp + 40} & \texttt{/bin/sh...} & Données brutes \\
        \hline
    \end{tabular}
    \caption{Organisation de la ROP Chain en mémoire}
\end{table}

\textbf{Justification de l'ordre d'écriture :}
Le script Python itère sur ce dictionnaire et écrit chaque élément (découpé en blocs de 32 bits) tout en réécrivant systématiquement \texttt{0xEE} à l'adresse \texttt{addr\_rip} pour maintenir le programme en vie.

Une fois tous les éléments en place (Gadget, Pointeur, System, Chaîne), la dernière étape consiste à écraser le Saved RIP (\texttt{addr\_rip}) non plus avec \texttt{0xEE}, mais avec l'adresse d'un petit gadget \texttt{RET} (\texttt{addr\_ret}).
Cela aura pour effet de "glisser" vers l'instruction suivante sur la pile (\texttt{RBP + 16}), déclenchant ainsi notre chaîne ROP.