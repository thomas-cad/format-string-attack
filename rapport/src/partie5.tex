\section{Construction de la boucle d'exploitation}

L'exploitation complète nécessite l'écriture de quatre éléments distincts sur la pile (Gadget, Pointeur, Fonction System, Chaîne brute). Le buffer d'entrée étant trop petit pour tout écrire en une fois, nous utilisons une \textbf{boucle d'exploitation}.

Cette technique consiste à forcer le programme à ré-exécuter la fonction vulnérable \texttt{makePing} indéfiniment tant que notre charge utile n'est pas complète, en modifiant l'adresse de retour à chaque itération.

\subsection{Mécanisme de réinvocation (LSB Overwrite)}

Normalement, l'instruction \texttt{ret} de \texttt{makePing} utilise l'adresse de retour (Saved RIP) pour revenir au \texttt{main}.
Pour relancer \texttt{makePing}, nous modifions l'octet de poids faible (LSB) de cette adresse pour qu'elle pointe vers l'instruction \texttt{call} précédente.

\subsubsection{Analyse des adresses dans le \texttt{main}}

\begin{lstlisting}[language=bash, basicstyle=\footnotesize\ttfamily, caption={Adresses autour de l'appel makePing}]
0x00005555555554ee <+24>:    call   0x5555555553b3 <makePing>
0x00005555555554f3 <+29>:    mov    $0x0,%eax  <-- Saved RIP actuel
\end{lstlisting}

\begin{itemize}
    \item \textbf{Adresse actuelle :} \texttt{...54\textbf{f3}}.
    \item \textbf{Adresse cible (Boucle) :} \texttt{...54\textbf{ee}}.
\end{itemize}

La différence ne réside que dans le dernier octet. En remplaçant \texttt{0xf3} par \texttt{0xee} via le spécificateur \texttt{\%hhn}, nous forçons le programme à sauter sur l'instruction \texttt{call}, relançant ainsi la fonction vulnérable.

\subsection{Algorithme de la boucle d'attaque}

Le script d'exploitation itère sur les éléments de la ROP chain pour les écrire en mémoire 32 bits par 32 bits (MSB/LSB).

\begin{enumerate}
    \item \textbf{Phase d'écriture (Boucle active) :}
    Pour chaque adresse de la ROP chain (\texttt{RBP+16}, \texttt{RBP+24}, etc.) :
    \begin{itemize}
        \item Nous envoyons un payload qui écrit 4 octets de données à l'adresse cible.
        \item Dans le \textbf{même payload}, nous écrivons la valeur \texttt{0xee} sur le LSB du Saved RIP (\texttt{RBP+8}).
        \item \textbf{Résultat :} La donnée est écrite, et la fonction redémarre au lieu de quitter.
    \end{itemize}

    \item \textbf{Phase de déclenchement (Trigger) :}
    Une fois la chaîne ROP complète (Gadget, Argument, System, Chaîne) écrite aux adresses supérieures, il faut briser la boucle.
    \begin{itemize}
        \item Nous envoyons un dernier payload.
        \item Cette fois, nous n'écrivons pas \texttt{0xee} (adresse du \texttt{call}), mais \texttt{\textbf{0xf9}} (adresse du gadget \texttt{ret} situé à la fin du main).
        \item \textbf{Résultat :} Au retour de \texttt{makePing}, le processeur saute sur le \texttt{ret} du \texttt{main}. Ce \texttt{ret} dépile la valeur suivante sur la pile (située à \texttt{RBP+16}), qui est notre gadget \texttt{POP RDI}. La chaîne ROP s'exécute.
    \end{itemize}
\end{enumerate}